import discord,os,json,asyncio,re
from discord import app_commands
from google import genai
from dotenv import load_dotenv


load_dotenv()
GOOGLE_AI_KEY = os.getenv("GOOGLE_AI_KEY")


genaitradutor = None



# ======================================================================
# CARREGANDO A API DO GEMINI PARA TRADUZIR AS COISAS
try:
    if not GOOGLE_AI_KEY:
        raise ValueError("API KEY ausente.")
    genaitradutor = genai.Client(api_key=GOOGLE_AI_KEY)
except Exception as e:
    print(f"‚ùå  -  Erro ao inicializar GenAI: {e}")
    print("‚ùå  -  Tradu√ß√£o por IA desativada.")













# ======================================================================
#sistema para traduzir para qualquer idioma que eu queira

class BrixTradutor(app_commands.Translator):
    def __init__(self, dir_name='src/core/traducoes', response_dir='src/core/responses'):
        print("üåê  -  Iniciando Tradu√ß√µes Autom√°ticas!")
        # Criar diret√≥rios, se n√£o existirem
        self.dir_name = dir_name
        self.response_dir = response_dir

        for directory in [self.dir_name, self.response_dir]:
            if not os.path.exists(directory):
                os.makedirs(directory)

        # Lista de idiomas suportados e nomes dos arquivos JSON
        self.allowed_locales = {
            discord.Locale.american_english: 'en-US',
            discord.Locale.spain_spanish: 'es-ES',
            #discord.Locale.japanese: 'ja',
            #discord.Locale.french: 'fr',
        }

        # Carregar tradu√ß√µes de comandos
        self.translations = self.load_translations(self.dir_name)

        # Carregar mensagens de resposta da pasta response/
        self.response_translations = self.load_translations(self.response_dir)













# ======================================================================
    def load_translations(self, directory):
        """Carrega ou cria arquivos de tradu√ß√£o para cada idioma."""
        translations = {}

        for locale, file_name in self.allowed_locales.items():
            file_path = os.path.join(directory, f"{file_name}.json")

            if os.path.exists(file_path):
                with open(file_path, 'r', encoding='utf-8') as f:
                    translations[locale] = json.load(f)
            else:
                translations[locale] = {}

        return translations














# ======================================================================
    async def translate(self, string: app_commands.locale_str, locale: discord.Locale, context: app_commands.TranslationContext):
        message_str = string.message

        # Se for portugu√™s, retorna o texto original
        if locale == discord.Locale.brazil_portuguese:
            return message_str

        # Se o idioma n√£o estiver na lista permitida, retorna o texto original
        if locale not in self.allowed_locales:
            return message_str

        # Nome do arquivo JSON correspondente
        file_name = self.allowed_locales[locale]
        file_path = os.path.join(self.dir_name, f"{file_name}.json")

        # Se a tradu√ß√£o j√° existir, retorna ela
        if message_str in self.translations[locale]:
            return self.translations[locale][message_str]

        await asyncio.sleep(2)
        # Traduzir a mensagem e armazenar
        target_lang = file_name.split('-')[0]    
        response = genaitradutor.models.generate_content(model="gemini-2.0-flash" , contents=f"voc√™ √© um tradutor e deve retornar apenas a tradu√ß√£o do texto enviado, mantendo qualquer emoji junto com seu ponto de separa√ß√£o caso tenha e qualquer indica√ß√£o em seu respectivo lugar, caso a mensagem j√° esteja no respectivo idioma mantem oque foi enviado, fa√ßa isso em {target_lang} para a seguinte mensagem: {message_str}") 
        translated_text = response.text

        # Ajustar formata√ß√£o da tradu√ß√£o (se for nome de comando)
        if " " in message_str:
            translated_text = translated_text.strip().lower()
        else:
            translated_text = translated_text.strip().replace(" ", "").lower()

        # Armazena a nova tradu√ß√£o
        self.translations[locale][message_str] = translated_text

        # Salvar no JSON correspondente
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(self.translations[locale], f, ensure_ascii=False, indent=4)

        print(f"‚úÖ - Traduzido comando para {file_name}: {translated_text}")
        return translated_text














# ======================================================================
    # TRADUTOR DAS RESPOSTAS DO BOT COM BASE NO ARQUIVO PRINCIPAL pt-BR
    async def translate_responses(self):
        # L√™ o arquivo pt-BR.json em response/ e gera as tradu√ß√µes para os outros idiomas.
        pt_br_file = os.path.join(self.response_dir, "pt-BR.json")

        if not os.path.exists(pt_br_file):
            print("Arquivo pt-BR.json n√£o encontrado em response/.")
            return

        with open(pt_br_file, 'r', encoding='utf-8') as f:
            pt_br_messages = json.load(f)

        for key, message in pt_br_messages.items():
            # Verifica se a mensagem √© uma lista
            if isinstance(message, list):
                messages_to_translate = message  # Se for uma lista, mant√©m como est√°
            elif isinstance(message, str):
                messages_to_translate = [message]  # Se for uma string, transforma em lista de 1 item
            else:
                continue  # Pula casos que n√£o s√£o nem string nem lista

            for locale, file_name in self.allowed_locales.items():
                target_lang = file_name.split('-')[0]
                response_file = os.path.join(self.response_dir, f"{file_name}.json")

                # Carrega as tradu√ß√µes existentes, se o arquivo j√° existir
                if os.path.exists(response_file):
                    with open(response_file, 'r', encoding='utf-8') as f:
                        translated_messages_dict = json.load(f)
                else:
                    translated_messages_dict = {}

                # Se a chave ainda n√£o existe, cria uma lista vazia
                if key not in translated_messages_dict:
                    translated_messages_dict[key] = []

                # Garantir que o valor para a chave seja uma lista
                if not isinstance(translated_messages_dict[key], list):
                    translated_messages_dict[key] = [translated_messages_dict[key]]

                # Verifica se a chave j√° existe e, se sim, pula a tradu√ß√£o para ela
                if key in translated_messages_dict and translated_messages_dict[key]:
                    continue  # Pula para a pr√≥xima chave

                for msg in messages_to_translate:
                    # Remove e armazena emojis personalizados
                    cleaned_message, emoji_positions = self.remove_custom_emojis(msg)
                    # Tradu√ß√£o
                    await asyncio.sleep(2)  # Evitar limites de taxa
                    response = genaitradutor.models.generate_content(model="gemini-2.0-flash" , contents=f"Voc√™ √© um tradutor e deve retornar apenas a tradu√ß√£o do texto enviado, mantendo qualquer emoji e formata√ß√£o. Se a mensagem j√° estiver em {target_lang}, mantenha o texto original. Traduza para {target_lang}: {cleaned_message}")
                    #response = text_model.generate_content( f"Voc√™ √© um tradutor e deve retornar apenas a tradu√ß√£o do texto enviado, mantendo qualquer emoji e formata√ß√£o. Se a mensagem j√° estiver em {target_lang}, mantenha o texto original. Traduza para {target_lang}: {cleaned_message}")
                    translated_text =  response.text.rstrip("\n") 

                    # Restaurar emojis
                    final_translated_text = self.restore_emojis(translated_text, emoji_positions)

                    # Adiciona a resposta traduzida na lista
                    if isinstance(message, list):
                        translated_messages_dict[key].append(final_translated_text)

                    elif isinstance(message, str):
                        # Se for uma string √∫nica, armazena diretamente sem a lista
                        translated_messages_dict[key] = final_translated_text  # N√£o usa append, armazena diretamente
                    print(f"Traduzido {key} para {file_name}")

                # Salvar o arquivo atualizado
                with open(response_file, 'w', encoding='utf-8') as f:
                    json.dump(translated_messages_dict, f, ensure_ascii=False, indent=4)

        print("üåê  -  Tradu√ß√µes conclu√≠das!")












# ======================================================================
    def remove_custom_emojis(self, message):
        """Remove emojis personalizados da mensagem e retorna o texto limpo e as posi√ß√µes dos emojis encontrados."""
        # Regex para identificar emojis personalizados
        emoji_pattern = r'(<:[a-zA-Z0-9_]+:[0-9]+>)'
        
        # Encontrar todos os emojis personalizados e suas posi√ß√µes
        emojis = re.findall(emoji_pattern, message)
        emoji_positions = []

        # Substituir os emojis por um marcador tempor√°rio e manter o emoji original (nome e ID)
        for i, emoji in enumerate(emojis):
            emoji_positions.append((i, emoji, message.find(emoji)))  # Armazenar o emoji e sua posi√ß√£o
            message = message.replace(emoji, f"E{i}", 1)  # Substitui o emoji por um marcador √∫nico
        
        return message, emoji_positions













# ======================================================================
    def restore_emojis(self, translated_text, emoji_positions):
        """Restaurar os emojis personalizados nas posi√ß√µes corretas da tradu√ß√£o."""
        # Restaurar os emojis nas posi√ß√µes corretas
        for i, emoji, position in reversed(emoji_positions):  # Coloca os emojis na posi√ß√£o original
            translated_text = translated_text[:position] + emoji + translated_text[position:]

        # Agora removemos os marcadores tempor√°rios
        translated_text = re.sub(r'[Ee]\d+', '', translated_text)  # Remove qualquer marcador EMOJI{i}

        return translated_text
